name: Test Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  checks: write
  contents: read
  packages: read
env:
  API_URL: https://app.dev.veribom.com

jobs:
  create_scan_in_IR_Portal:
    runs-on: ubuntu-latest
    outputs:
      scan_id: ${{ steps.parseResponse.outputs.scan_id }}
    steps:
      - name: Initiating SBOM Scan
        id: createScan
        uses: fjogeleit/http-request-action@v1.15.1
        with:
          url: '${{env.API_URL}}/utilityapi/v1/scan'
          method: 'POST'
          data: '{"api_key": "pZLbsA13Cb43XOFKijs4cEUatABd18xJtT1apqcDls9egVGo6CpMpf5SrNjKigNKdCM3NCN-ZG0N5Fv1oKT7Qg"}'
      - name: Parse Response
        id: parseResponse
        run: echo "scan_id=${{fromJSON(steps.createScan.outputs.response).data.scan_id}}" >> "$GITHUB_OUTPUT"
  ecr_details:
    runs-on: ubuntu-latest
    outputs:
      ecr_username: ${{steps.ecr_details.outputs.username}}
      ecr_token: ${{steps.ecr_details.outputs.token}}
      ecr_region: ${{steps.ecr_details.outputs.region}}
      ecr_id: ${{steps.ecr_details.outputs.registry_id}}
    steps:
      - name: Fetching VB Token
        id: fetchECRDetails
        uses: fjogeleit/http-request-action@v1.15.1
        with:
            url: '${{env.API_URL}}/utilityapi/v1/registry?api_key=pZLbsA13Cb43XOFKijs4cEUatABd18xJtT1apqcDls9egVGo6CpMpf5SrNjKigNKdCM3NCN-ZG0N5Fv1oKT7Qg'
            method: 'GET'
      - name: Decoding VB Token
        id: parseToken
        run: echo "DECODED_TOKEN=$(echo ${{ fromJson(steps.fetchECRDetails.outputs.response).data }} | base64 -d)" >> "$GITHUB_OUTPUT"
      - name: ECR Details
        id: ecr_details
        run: |
          echo "username=${{fromJSON(steps.parseToken.outputs.DECODED_TOKEN).username}}" >> "$GITHUB_OUTPUT"
          echo "token=${{fromJSON(steps.parseToken.outputs.DECODED_TOKEN).password}}" >> "$GITHUB_OUTPUT"
          echo "region=${{fromJSON(steps.parseToken.outputs.DECODED_TOKEN).region}}" >> "$GITHUB_OUTPUT"
          echo "registry_id=${{fromJSON(steps.parseToken.outputs.DECODED_TOKEN).registry_id}}" >> "$GITHUB_OUTPUT"

  start_proxy_and_build:
    runs-on: ubuntu-latest
    needs: [create_scan_in_IR_Portal, ecr_details]
    services:
      pse:
        image: 282904853176.dkr.ecr.us-west-2.amazonaws.com/invisirisk/pse-proxy:latest
        credentials:
          username: ${{needs.ecr_details.outputs.ecr_username}}
          password: ${{needs.ecr_details.outputs.ecr_token}}
        env:
          PSE_DEBUG_FLAG: --alsologtostderr
          POLICY_LOG: t
          INVISIRISK_JWT_TOKEN: pZLbsA13Cb43XOFKijs4cEUatABd18xJtT1apqcDls9egVGo6CpMpf5SrNjKigNKdCM3NCN-ZG0N5Fv1oKT7Qg
          INVISIRISK_PORTAL:  https://app.dev.veribom.com
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    # container:
    #   image: node:18-alpine
    #   options: --cap-add=NET_ADMIN
    # strategy:
    #   matrix:
    #     node-version: [18.x]
    steps:
    - name: Install Docker
      run: getent hosts
    - name: Install Docker ps
      run: docker ps
    # - name: Get PSE container IP
    #   run: |
    #     CONTAINER_NAME=$(docker ps --filter "ancestor=282904853176.dkr.ecr.us-west-2.amazonaws.com/invisirisk/pse-proxy:latest" --format "{{.Names}}")
    #     PSE_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $CONTAINER_NAME)
    #     echo "PSE container IP is ${PSE_IP}"
    
    - name: Install diagnostic tools
      run: |
        sudo apt-get update && sudo apt-get install -y dnsutils netcat-openbsd curl iputils-ping iptables ca-certificates git python3 python3-pip openssl
        
    - name: Ip tables setup 
      run: |
        # sudo apt update
        # sudo apt install iptables
        sudo iptables -t nat -N pse
        sudo iptables -t nat -A OUTPUT -j pse
        echo "Setting up PSE"
        CONTAINER_NAME=$(docker ps --filter "ancestor=282904853176.dkr.ecr.us-west-2.amazonaws.com/invisirisk/pse-proxy:latest" --format "{{.Names}}")
        PSE_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $CONTAINER_NAME)
        echo "PSE container IP is ${PSE_IP}"
        sudo iptables -t nat -A pse -p tcp -m tcp --dport 443 -j DNAT --to-destination ${PSE_IP}:12345
        sudo iptables -S

    - name: Download CA certificate
      run: |
        BASE_URL="https://pse.invisirisk.com"
        CA_FILE="/etc/ssl/certs/pse.pem"
        sudo curl -v -s -o /etc/ssl/certs/pse.pem https://pse.invisirisk.com/ca \
            -H 'User-Agent: Jenkins' \
            --insecure || exit 1
        if [ ! -f "$CA_FILE" ]; then
          echo "Certificate file does not exist after download"
          exit 1
        fi
        if [ ! -s "$CA_FILE" ]; then
          echo "Downloaded certificate is empty"
          exit 1
        fi
        update-ca-certificates
    - name: Send start notification to PSE
      run: |
        send_start_notification() {
            BASE_URL="https://pse.invisirisk.com"
            local build_url="$1"
            git_url=$(git config --get remote.origin.url)
            git_branch=$(git rev-parse --abbrev-ref HEAD)
            git_commit=$(git rev-parse HEAD)
            repo_name=$(basename -s .git $git_url)

            params="builder=$(url_encode "jenkins")"
            params="${params}&id=$(url_encode "$SCAN_ID")"
            params="${params}&build_id=$(url_encode "$GITHUB_RUN_ID")"
            params="${params}&build_url=$(url_encode "$build_url")"
            params="${params}&project=$(url_encode "${repo_name:-$JOB_NAME}")"
            params="${params}&workflow=$(url_encode "$JOB_NAME")"
            params="${params}&builder_url=$(url_encode "$localhost")"
            params="${params}&scm=$(url_encode "git")"
            params="${params}&scm_commit=$(url_encode "$git_commit")"
            params="${params}&scm_branch=$(url_encode "$git_branch")"
            params="${params}&scm_origin=$(url_encode "$git_url")"

            curl -X POST "${BASE_URL}/start" \
                -H 'Content-Type: application/x-www-form-urlencoded' \
                -H 'User-Agent: pse-action' \
                -d "$params" \
                -k --tlsv1.2 --insecure \
                --retry 3 --retry-delay 2 --max-time 10 || true
        }
        
    - name: Node Certificate 
      run: |
          export NODE_EXTRA_CA_CERTS=/etc/ssl/certs/cert.pem
          export REQUESTS_CA_BUNDLE=/etc/ssl/certs/cert.pem
          npm config set cafile /etc/ssl/certs/cert.pem
          npm config set strict-ssl false
    - env: 
        SCAN_ID: ${{ needs.create_scan_in_IR_Portal.outputs.scan_id }}
      run: echo $SCAN_ID
          
    - name: Check out code
      uses: actions/checkout@v3
    - name: Build Docker image
      run: |
          docker build -t test-app:latest .
          
      # - name: Test container
      #   run: |
      #     docker run -d -p 3000:3000 --name test-container test-app:latest
      #     sleep 5  # Wait for container to start
      #     curl http://localhost:3000/
      #     curl http://localhost:3000/test-external
      #     docker logs test-container
          
      # # Test Docker-in-Docker scenario
      # - name: Test Docker-in-Docker
      #   run: |
      #     # Create a test Dockerfile for nested build
      #     echo "FROM ubuntu:20.04" > Dockerfile.nested
      #     echo "RUN apt-get update && apt-get install -y curl" >> Dockerfile.nested
          
      #     docker run --privileged \
      #       -v /var/run/docker.sock:/var/run/docker.sock \
      #       -v $(pwd)/Dockerfile.nested:/app/Dockerfile.nested \
      #       test-app:latest \
      #       docker build -t nested-image -f Dockerfile.nested .
